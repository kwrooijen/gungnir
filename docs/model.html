<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Model</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Gungnir</span> <span class="project-version">0.0.1-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="README.html"><div class="inner"><span>Gungnir</span></div></a></li><li class="depth-1 "><a href="guide.html"><div class="inner"><span>Guide</span></div></a></li><li class="depth-1 "><a href="database.html"><div class="inner"><span>Database</span></div></a></li><li class="depth-1 "><a href="migrations.html"><div class="inner"><span>Migrations</span></div></a></li><li class="depth-1  current"><a href="model.html"><div class="inner"><span>Model</span></div></a></li><li class="depth-1 "><a href="changeset.html"><div class="inner"><span>Changeset</span></div></a></li><li class="depth-1 "><a href="query.html"><div class="inner"><span>Query</span></div></a></li><li class="depth-1 "><a href="transactions.html"><div class="inner"><span>Transactions</span></div></a></li><li class="depth-1 "><a href="ui.html"><div class="inner"><span>UI</span></div></a></li><li class="depth-1 "><a href="form.html"><div class="inner"><span>Form</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>gungnir</span></div></div></li><li class="depth-2 branch"><a href="gungnir.changeset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>changeset</span></div></a></li><li class="depth-2"><a href="gungnir.database.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>database</span></div></a></li><li class="depth-3"><a href="gungnir.database.builder.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>builder</span></div></a></li><li class="depth-2 branch"><a href="gungnir.decode.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>decode</span></div></a></li><li class="depth-2 branch"><a href="gungnir.factory.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>factory</span></div></a></li><li class="depth-2 branch"><a href="gungnir.field.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>field</span></div></a></li><li class="depth-2 branch"><a href="gungnir.model.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>model</span></div></a></li><li class="depth-2 branch"><a href="gungnir.query.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>query</span></div></a></li><li class="depth-2 branch"><a href="gungnir.record.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>record</span></div></a></li><li class="depth-2 branch"><a href="gungnir.spec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>spec</span></div></a></li><li class="depth-2 branch"><a href="gungnir.transaction.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transaction</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></div></li><li class="depth-3"><a href="gungnir.util.malli.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>malli</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#model" name="model"></a>Model</h1>
<h2><a href="#malli-schemas" name="malli-schemas"></a>Malli Schemas</h2>
<p>Models in Gungnir are defined using <a href="https://github.com/metosin/malli/">malli</a>. These models define your Clojure data structures, and how they interact with your database.</p>
<ul>
  <li>Only data you describe as valid will be saved to the database.</li>
  <li>Perform transformations to your data when reading / writing to the database.</li>
  <li>Create descriptive error messages for your end users.</li>
</ul>
<pre><code class="clojure">;; Define a user model

(def user-model
 [:map
  {:has-many {:user/posts {:model :post :foreign-key :post/user-id}
              :user/comments {:model :comment :foreign-key :comment/user-id}}}
  [:user/id {:primary-key true} uuid?]
  [:user/email {:before-save [:string/lower-case]
                :before-read [:string/lower-case]}
   [:re {:error/message "Invalid email"} #".+@.+\..+"]]
  [:user/password {:before-save [:bcrypt]} [:string {:min 6}]]
  [:user/password-confirmation {:virtual true} [:string {:min 6}]]
  [:user/created-at {:auto true} inst?]
  [:user/updated-at {:auto true} inst?]])
</code></pre>
<h2><a href="#registering-models" name="registering-models"></a>Registering Models</h2>
<p>Models can be registered using the <code>gungnir.model/register!</code> function. Generally you’d want your system state manager to manage this. E.g. Integrant, Component, Mount.</p>
<pre><code class="clojure">(gungnir.model/register!
 {:user user-model
  :post post-model
  :comment comment-model})
</code></pre>
<h2><a href="#model-properties" name="model-properties"></a>Model properties</h2>
<h3><code>:table</code></h3>
<p>Specify the table you’d like to use for this model. By default the model name will be used as the table. For example you might have a <code>:user</code> model, but you want to target the “users” table.</p>
<pre><code class="clojure">{:user
 [:map
  {:table :users}
  [:user/email string?]}
</code></pre>
<h3><code>:has-many</code></h3>
<p>Describe a <code>:has-many</code> relation which can be queried through the current model. This relational query will return a vector of maps.</p>
<pre><code class="clojure">[:map
 {:has-many {:user/posts {:model :post :foreign-key :post/user-id}}}
 ,,,]
</code></pre>
<h3><code>:has-one</code></h3>
<p>Describe a <code>:has-one</code> relation which can be queried through the current model. This relational query will return a single map or <code>nil</code>.</p>
<pre><code class="clojure">[:map
 {:has-one {:user/reset-token {:model :reset-token :foreign-key :reset-token/user-id}}}
 ,,,]
</code></pre>
<h3><code>:belongs-to</code></h3>
<p>Describe a <code>:belongs-to</code> relation which can be queried through the current model. This relational query will return a single map or <code>nil</code>.</p>
<pre><code class="clojure">[:map
 {:belongs-to {:post/user {:model :user :foreign-key :post/user-id}}}
 ,,,]
</code></pre>
<h2><a href="#model-field-properties" name="model-field-properties"></a>Model Field properties</h2>
<p>Malli schemas support adding properties. Gungnir has a few custom properties that can be used.</p>
<h3><a href="#required-" name="required-"></a><code>:primary-key</code> (required)</h3>
<p>Describe which key is the <code>PRIMARY KEY</code> in your table. This is required for Gungnir to be able to make use of the querying API, as well as the relational mapping.</p>
<pre><code class="clojure">[:user/id {:primary-key true} uuid?]
</code></pre>
<h3><code>:auto</code></h3>
<p>Tell Gungnir that this key is automatically managed by the database, and Gungnir should never make an attempt to modify it. This is useful for e.g. <code>TIMESTAMP</code> columns which might be updated automatically.</p>
<pre><code class="sql">created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
</code></pre>
<pre><code class="clojure">[:user/created-at {:auto true} inst?]
</code></pre>
<h3><code>:virtual</code></h3>
<p>Tell Gungnir that you want this key to be part of your Model, but it does not exist as a column in the database. Gungnir will make no attempt to query, or save this key. Useful for things such as password-confirmation fields.</p>
<pre><code class="clojure">[:user/password-confirmation {:virtual true} string?]
</code></pre>
<h3><code>:before-save</code></h3>
<p>Add hooks to a column to be executed before you save them to the database. This is useful to keep data transformations consistent. For example you always want to encrypt passwords before saving them to the database. Passwords could be set during creating, updated on the profile page, changed through a password reset. In all of these cases you must encrypt the user’s inputted password before inserting it to the database.</p>
<p>Add a <code>:bcrypt</code> key to the <code>:before-save</code> vector for <code>:user/password</code>.</p>
<pre><code class="clojure">[:user/password {:before-save [:bcrypt]} string?]
</code></pre>
<p>And define the <code>:bcrypt</code> <code>:before-save</code> handler. Handlers take the key and value of field in question. The resulting value of <code>gungnir.model/before-save</code> will be saved in the database.</p>
<pre><code class="clojure">(defmethod gungnir.model/before-save :bcrypt [_k v]
  (buddy.hashers/derive v))
</code></pre>
<h3><code>:before-read</code></h3>
<p>Add hooks to a column to be executed before you read it from database. This is useful if want to sanitize any query parameters before reading. For example you could save all emails as lowercase (with the <code>gungnir.model/before-save</code> hook). Then add a <code>:before-read</code> hook to lowercase the email field when you query the database. That way you’ll be able to deal with case sensitive data.</p>
<p>Add the <code>:before-save</code> and <code>:before-read</code> hooks.</p>
<pre><code class="clojure">[:user/email 
 {:before-save [:string/lower-case]
  :before-read [:string/lower-case]}
 [:re #".+@.+\..+"]]
</code></pre>
<p>Define the hooks to be used</p>
<pre><code class="clojure">(defmethod gungnir.model/before-save :string/lower-case [_k v]
  (clojure.string/lower-case v))

(defmethod gungnir.model/before-read :string/lower-case [_k v]
  (clojure.string/lower-case v))
</code></pre>
<p>Gungnir has the <code>:string/lower-case</code> hooks built-in, so you don’t have to define them yourself.</p>
<h3><code>:after-read</code></h3>
<p>Add hooks to a column to be executed after you read it from database. You could encrypt data before saving it, and decrypt it after reading it for extra security. Another use case is saving keywords to the database as strings, and parsing it as EDN after reading it.</p>
<p>In this case, user has an <code>:user/option</code> key, which is a qualified-keyword. You can’t store keywords in SQL, so they’re converted to strings.</p>
<pre><code class="clojure">[:user/option 
 {:after-read [:edn/read-string]}
 [:enum :option/one :option/two :option/three]]
</code></pre>
<p>Define the <code>:edn/read-string</code> hook to convert the keywords. <code>:edn/read-string</code> is also built-in Gungnir, so you don’t have to defined it yourself.</p>
<pre><code class="clojure">(defmethod after-read :edn/read-string [_ v]
  (if (vector? v)
    (mapv edn/read-string v)
    (edn/read-string v)))
</code></pre>
<h2><a href="#model-relation-definitions" name="model-relation-definitions"></a>Model Relation Definitions</h2>
<p>Gungnir can handle relational mapping for you. This is done by adding relation definitions to the models properties. For more information regarding querying relations visit the <a href="https://kwrooijen.github.io/gungnir/query.html">query</a> page.</p>
<h3><a href="#example" name="example"></a>Example</h3>
<p>In the example below we define the following relations:</p>
<ul>
  <li>user <strong>has_many</strong> comments, through <code>:user/comments</code></li>
  <li>user <strong>has_many</strong> posts, through <code>:user/posts</code></li>
  <li>post <strong>belongs_to</strong> user, through <code>:post/user</code></li>
  <li>post <strong>has_many</strong> comments, through <code>:post/comments</code></li>
  <li>comment <strong>belongs_to</strong> post, through <code>:comment/user</code></li>
  <li>comment <strong>belongs_to</strong> user, through <code>:comment/post</code></li>
</ul>
<pre><code class="clojure">(def model-user
 [:map
  {:has-many {:user/posts {:model :post :foreign-key :post/user-id}
              :user/comments {:model :comment :foreign-key :comment/user-id}}}
  [:user/id {:primary-key true} uuid?]
  ,,,])

(def model-post
 [:map
  {:belongs-to {:post/user {:model :user :foreign-key :post/user-id}}
   :has-many {:post/comments {:model :comment :foreign-key :comment/post-id}}}
  [:post/id {:primary-key true} uuid?]
  [:post/user-id uuid?]
  ,,,])

(def model-comment
 [:map
  {:belongs-to {:comment/user {:model :user :foreign-key :comment/user-id}
                :comment/post {:model :post :foreign-key :comment/post-id}}}
  [:comment/id {:primary-key true} uuid?]
  [:comment/user-id uuid?]
  [:comment/post-id uuid?]
  ,,,])
</code></pre>
<h2><a href="#model-validators" name="model-validators"></a>Model Validators</h2>
<p>In some situations you will want to have extra validations. Visit the <a href="https://kwrooijen.github.io/gungnir/changeset.html">changeset</a> page to learn how to use validators.</p>
<p>Validators are defined using the <code>gungnir.model/validator</code> multimethod. Which is matched with a <code>qualified-keyword</code>.</p>
<p>The <code>gungnir.model/validator</code> multimethod should return the following map.</p>
<ul>
  <li><code>:validator/key</code> - The key this validator is related to. If the validator  check fails it will mark this key as the failing key.</li>
  <li><code>:validator/fn</code> - The function to be run to check the validation. This  function takes a single argument, which is the map that is being validated.</li>
  <li><code>:validator/message</code> - The error message to be displayed when the validation  check fails. This will be assigned to the <code>:validation/key</code> as its error.</li>
</ul>
<h3><a href="#example" name="example"></a>Example</h3>
<p>Check if the <code>:user/password</code> and <code>:user/password-validation</code> match during registration. Since <code>:map</code> keys are isolated from each other this would be a good solution.</p>
<pre><code class="clojure">(defn password-match? [m]
  (= (:user/password m)
     (:user/password-confirmation m)))

(defmethod gungnir.model/validator :user/password-match? [_]
  {:validator/key :user/password-confirmation
   :validator/fn password-match?
   :validator/message "Passwords don't match"})
</code></pre>
<h2><a href="#model-database-error-formatting" name="model-database-error-formatting"></a>Model Database Error Formatting</h2>
<p>Sometimes even with the perfect model you can still gets errors from the database. This can happen when you try to insert a row which contains an existing key with a <code>UNIQUE CONSTRAINT</code>. Normally JDBC would throw an exception for these cases. Gungnir will instead catch them and place them in your <a href="https://kwrooijen.github.io/gungnir/changeset.html">changesets</a> <code>:changeset/errors</code> key. This error will be identified with a unique keyword and can be modified per field using the <code>gungnir.model/format-error</code> multimethod.</p>
<h3><a href="#example" name="example"></a>Example</h3>
<p>During registration, you won’t know if an email exists until you hit the database. If an email exists (assuming you have a <code>UNIQUE CONSTRAINT</code> on the email column) Gungnir will return a <code>:duplicate-key</code> error. This error can transformed to make it more understandable for your end users.</p>
<pre><code class="clojure">(defmethod gungnir.model/format-error [:user/email :duplicate-key] [_ _]
  "Email already exists")
</code></pre>
<p>Note: Gungnir is in its early stages, and only few errors are handled. If an unhandled error occurs gungnir will instead of keyword return a Postgresql exception code. Read more at the <a href="https://kwrooijen.github.io/gungnir/database.html">database</a> section.</p>
<hr />
<div class="footer-navigation">
<span>Previous: <a href="https://kwrooijen.github.io/gungnir/migrations.html">migrations</a></span>
<span>Next: <a href="https://kwrooijen.github.io/gungnir/changeset.html">changeset</a></span>
</div></div></div></div></body></html>